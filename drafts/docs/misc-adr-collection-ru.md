# Architecture Decision Records

## Оглавление

- [ADR-001: Использование Clean Architecture с первого дня](#adr-001)
- [ADR-002: Test-Driven Development как основная практика](#adr-002)
- [ADR-003: Монорепозиторий с yarn workspaces](#adr-003)
- [ADR-004: localStorage для прототипа](#adr-004)
- [ADR-005: UUID для идентификации тегов](#adr-005)
- [ADR-006: TypeScript для всех слоёв](#adr-006)
- [ADR-007: React для презентационного слоя](#adr-007)
- [ADR-008: Отказ от Redux в пользу встроенных React hooks](#adr-008)

---

## ADR-001: Использование Clean Architecture с первого дня {#adr-001}

**Дата**: 2025-08-26  
**Статус**: Принято  
**Автор**: Команда MISC  

### Контекст

Разрабатываем прототип минималистичной системы управления информацией. Обычно для прототипов используют упрощённую архитектуру, но мы хотим заложить правильный фундамент с самого начала.

### Рассмотренные варианты

1. **Простая двухслойная архитектура** (UI + Data)
   - ✅ Быстрая разработка прототипа
   - ❌ Сложная миграция на нормальную архитектуру
   - ❌ Бизнес-логика размазана между UI и Data

2. **MVC/MVP**
   - ✅ Проверенный паттерн
   - ❌ Всё ещё сильная связанность
   - ❌ Сложности с тестированием бизнес-логики

3. **Clean Architecture (Onion/Hexagonal)**
   - ✅ Независимость бизнес-логики
   - ✅ Отличная тестируемость
   - ✅ Легко менять детали реализации
   - ❌ Больше начального boilerplate
   - ❌ Может быть overkill для простого прототипа

### Решение

Используем **Clean Architecture** с чёткими слоями:

- Domain (сущности, value objects, доменные сервисы)
- Application (use cases, порты)
- Infrastructure (репозитории, внешние сервисы)
- Presentation (UI компоненты)

### Обоснование

1. **Независимость от UI**: Сможем переиспользовать код между web и CLI версиями (используя Ink для React в терминале)
2. **Независимость от хранилища**: Миграция с localStorage на PostgreSQL будет тривиальной
3. **Тестируемость**: Бизнес-логику можно тестировать без UI и БД
4. **Долгосрочная выгода**: Не придётся переписывать при росте проекта
5. **Множественные интерфейсы**: Web, CLI, и потенциально API - все используют одну бизнес-логику

### Последствия

**Положительные**:

- Чистая, тестируемая бизнес-логика с первого дня
- Легко добавлять новые способы хранения и представления
- Новые разработчики быстро понимают структуру
- Возможность параллельной разработки слоёв
- Реальное переиспользование кода между web и CLI благодаря Ink

**Отрицательные**:

- Дополнительное время на начальную настройку (~2-3 дня)
- Больше файлов и папок для простого функционала
- Необходимость следить за границами слоёв
- Риск over-engineering для простых фич

---

## ADR-002: Test-Driven Development как основная практика {#adr-002}

**Дата**: 2025-08-26  
**Статус**: Принято  
**Автор**: Команда MISC  

### Контекст

Нужно выбрать подход к разработке и тестированию. Для прототипа часто пренебрегают тестами, но мы хотим высокое качество с самого начала.

### Рассмотренные варианты

1. **Без тестов на этапе прототипа**
   - ✅ Максимальная скорость разработки
   - ❌ Технический долг
   - ❌ Страх рефакторинга
   - ❌ Баги в продакшене

2. **Тесты после реализации**
   - ✅ Не замедляет начальную разработку
   - ❌ Часто тесты так и не пишутся
   - ❌ Сложнее тестировать уже написанный код
   - ❌ Дизайн не оптимизирован для тестирования

3. **Test-Driven Development (TDD)**
   - ✅ Гарантированное покрытие тестами
   - ✅ Лучший дизайн кода
   - ✅ Уверенность при рефакторинге
   - ✅ Документация через тесты
   - ❌ Кажется медленнее на старте
   - ❌ Требует дисциплины

### Решение

Применяем **TDD** для всей бизнес-логики:

- Red: Пишем падающий тест
- Green: Минимальная реализация
- Refactor: Улучшаем код

### Обоснование

1. **Clean Architecture требует тестов**: Независимость слоёв проверяется тестами
2. **Документация**: Тесты показывают как использовать код
3. **Уверенность**: Можем рефакторить без страха
4. **Качество дизайна**: TDD естественно ведёт к слабой связанности

### Последствия

**Положительные**:

- 95%+ покрытие доменного слоя
- Меньше багов в продакшене
- Быстрая обратная связь при разработке
- Живая документация в виде тестов

**Отрицательные**:

- Начальное замедление разработки (~20%)
- Необходимость обучения команды TDD
- Поддержка тестов при изменении требований
- Соблазн пропустить TDD для "простых" фич

---

## ADR-003: Монорепозиторий с yarn workspaces {#adr-003}

**Дата**: 2025-08-26  
**Статус**: Принято  
**Автор**: Команда MISC  

### Контекст

Clean Architecture подразумевает чёткое разделение на слои. Нужно решить, как организовать код: один репозиторий или несколько.

### Рассмотренные варианты

1. **Всё в одном пакете**
   - ✅ Просто начать
   - ❌ Сложно контролировать зависимости между слоями
   - ❌ Один package.json становится огромным

2. **Отдельные репозитории**
   - ✅ Максимальная изоляция
   - ✅ Независимое версионирование
   - ❌ Сложность синхронизации изменений
   - ❌ Overhead на поддержку нескольких репо

3. **Монорепозиторий с workspaces**
   - ✅ Чёткие границы пакетов
   - ✅ Единая версия, но раздельные зависимости
   - ✅ Атомарные коммиты across packages
   - ❌ Начальная настройка
   - ❌ Все видят весь код

### Решение

**Монорепозиторий** со структурой:

```
misc/
├── packages/
│   ├── domain/       # Чистая бизнес-логика
│   ├── application/  # Use cases
│   ├── infrastructure/ # Адаптеры
│   └── web/         # React приложение
├── package.json
└── yarn.lock
```

### Обоснование

1. **Контроль зависимостей**: Domain не может импортировать из Infrastructure
2. **Переиспользование**: Shared типы легко расшарить
3. **Рефакторинг**: Изменения across packages в одном PR
4. **CI/CD**: Один pipeline для всего проекта

### Последствия

**Положительные**:

- Строгий контроль направления зависимостей
- Легко добавить новые packages (cli, mobile)
- Единообразная настройка линтеров и тестов
- Простая локальная разработка

**Отрицательные**:

- Время на настройку workspaces
- Все packages версионируются вместе
- Потенциально большой размер репозитория
- Нужно следить за циклическими зависимостями

---

## ADR-004: localStorage для прототипа {#adr-004}

**Дата**: 2025-08-26  
**Статус**: Принято  
**Автор**: Команда MISC  
**Заменяет**: -  
**Заменено**: Будет заменено в MVP на PostgreSQL  

### Контекст

Для прототипа нужно выбрать способ хранения данных. Важна скорость разработки и возможность работы без backend.

### Рассмотренные варианты

1. **In-memory (без персистентности)**
   - ✅ Максимально просто
   - ❌ Данные теряются при перезагрузке
   - ❌ Плохой UX

2. **IndexedDB**
   - ✅ Большой объём данных (50MB+)
   - ✅ Хорошая производительность
   - ❌ Сложное API
   - ❌ Асинхронность усложняет код

3. **localStorage**
   - ✅ Простое синхронное API
   - ✅ Достаточно для прототипа (5-10MB)
   - ✅ Работает везде
   - ❌ Ограничение по объёму
   - ❌ Только строки

4. **SQLite через WASM**
   - ✅ Полноценная БД
   - ❌ Сложность настройки
   - ❌ Большой размер bundle

### Решение

Используем **localStorage** с JSON сериализацией для прототипа.

### Обоснование

1. **Скорость разработки**: Можем запустить прототип за неделю
2. **Достаточный объём**: 5MB хватит для ~10,000 записей
3. **Clean Architecture**: Легко заменим на PostgreSQL через порты
4. **Простота отладки**: Данные видны в DevTools

### Последствия

**Положительные**:

- Запуск прототипа через неделю вместо месяца
- Нет необходимости в backend инфраструктуре
- Работает offline
- Простой экспорт/импорт через JSON

**Отрицательные**:

- Ограничение 5-10MB
- Нет конкурентного доступа
- Необходимость миграции данных при переходе на PostgreSQL
- Производительность деградирует при большом объёме

**План миграции**:
При переходе на MVP создадим PostgreSQLRepository, реализующий тот же интерфейс что и LocalStorageRepository.

---

## ADR-005: UUID для идентификации тегов {#adr-005}

**Дата**: 2025-08-26  
**Статус**: Принято  
**Автор**: Команда MISC  

### Контекст

Нужно решить, как идентифицировать теги в системе. Это критично для связи записей с тегами и для будущих features (переименование, слияние тегов).

### Рассмотренные варианты

1. **Строка тега как ID**
   - ✅ Просто и очевидно
   - ❌ Невозможно переименовать тег
   - ❌ Проблемы с регистром и нормализацией
   - ❌ Проблемы с Unicode

2. **Автоинкрементный ID**
   - ✅ Компактно
   - ❌ Сложности с синхронизацией
   - ❌ Проблемы при импорте/экспорте
   - ❌ Требует централизованного счётчика

3. **UUID**
   - ✅ Глобальная уникальность
   - ✅ Работает offline
   - ✅ Легко мержить данные
   - ✅ Иммутабельный идентификатор
   - ❌ Занимает больше места (36 символов)
   - ❌ Не human-readable

4. **Хеш от значения**
   - ✅ Детерминированный
   - ❌ Коллизии
   - ❌ Нельзя переименовать

### Решение

Используем **UUID v4** для всех тегов и записей.

### Обоснование

1. **Будущие фичи**: Переименование и слияние тегов
2. **Синхронизация**: Готовы к multi-device с первого дня
3. **Импорт/экспорт**: Сохраняем идентичность при переносе
4. **Отсутствие коллизий**: Критично для целостности данных

### Последствия

**Положительные**:

- Возможность переименования тегов без потери связей
- Простое слияние данных от разных пользователей
- Готовность к распределённой архитектуре
- Стабильные ссылки на теги

**Отрицательные**:

- Увеличение размера хранимых данных (~20%)
- Необходимость маппинга UUID ↔ значение
- Усложнение отладки (UUID не читаемы)
- Дополнительный lookup при поиске

---

## ADR-006: TypeScript для всех слоёв {#adr-006}

**Дата**: 2025-08-26  
**Статус**: Принято  
**Автор**: Команда MISC  

### Контекст

Выбираем язык программирования для всех слоёв приложения. Важны типобезопасность, tooling и developer experience.

### Рассмотренные варианты

1. **JavaScript**
   - ✅ Нет этапа компиляции
   - ✅ Максимальная гибкость
   - ❌ Нет типов
   - ❌ Больше runtime ошибок
   - ❌ Хуже IDE поддержка

2. **TypeScript**
   - ✅ Статическая типизация
   - ✅ Отличный IDE support
   - ✅ Ловим ошибки на этапе компиляции
   - ✅ Самодокументируемость
   - ❌ Этап компиляции
   - ❌ Иногда сложные типы

3. **ReScript/ReasonML**
   - ✅ Ещё строже типизация
   - ✅ Функциональная парадигма
   - ❌ Маленькое сообщество
   - ❌ Сложность найма

### Решение

**TypeScript** с строгими настройками:

- `strict: true`
- `noImplicitAny: true`
- `strictNullChecks: true`

### Обоснование

1. **Clean Architecture**: Интерфейсы и типы критичны для границ слоёв
2. **TDD**: Типы помогают в рефакторинге
3. **Domain модель**: Value Objects естественно выражаются через типы
4. **Монорепозиторий**: Shared типы между packages

### Последствия

**Положительные**:

- Ошибки ловятся при компиляции
- Отличный автокомплит и рефакторинг
- Типы как документация
- Безопасный рефакторинг across packages

**Отрицательные**:

- Необходимость в build step
- Время на написание типов
- Иногда борьба с типами
- Увеличение времени CI

---

## ADR-007: React для презентационного слоя {#adr-007}

**Дата**: 2025-08-26  
**Статус**: Принято  
**Автор**: Команда MISC  

### Контекст

Нужно выбрать UI фреймворк для web-версии. При Clean Architecture это не критичное решение (можно поменять), но влияет на скорость разработки.

### Рассмотренные варианты

1. **Vanilla JS**
   - ✅ Нет зависимостей
   - ✅ Максимальный контроль
   - ❌ Много boilerplate
   - ❌ Сложно поддерживать

2. **React**
   - ✅ Огромная экосистема
   - ✅ Легко найти разработчиков
   - ✅ Хорошо с TypeScript
   - ✅ Простые компоненты для простого UI
   - ❌ Нужен bundler
   - ❌ Относительно большой размер

3. **Vue 3**
   - ✅ Проще для начинающих
   - ✅ Хорошая производительность
   - ❌ Меньше экосистема
   - ❌ Composition API похож на React Hooks

4. **Svelte**
   - ✅ Компилируется в vanilla JS
   - ✅ Маленький bundle
   - ❌ Маленькое сообщество
   - ❌ Отход от стандартов

5. **Web Components**
   - ✅ Нативные стандарты
   - ✅ Framework-агностик
   - ❌ Сложное API
   - ❌ Плохая поддержка SSR

### Решение

**React** с функциональными компонентами и hooks.

### Обоснование

1. **Простота UI**: Для минималистичного интерфейса React не overkill
2. **Экосистема**: Готовые решения для всего
3. **Clean Architecture**: React останется только в presentation слое
4. **Команда**: Все знают React

### Последствия

**Положительные**:

- Быстрый старт разработки
- Много готовых компонентов
- Легко найти помощь
- Хорошая интеграция с TypeScript

**Отрицательные**:

- Bundle size ~40KB gzipped
- Необходимость в Vite/Webpack
- Virtual DOM overhead для простого UI
- Возможный over-engineering

---

## ADR-008: Отказ от Redux в пользу встроенных React hooks {#adr-008}

**Дата**: 2025-08-26  
**Статус**: Принято  
**Автор**: Команда MISC  

### Контекст

Нужно решить, как управлять состоянием в React приложении. UI минималистичный, но состояние может быть сложным (теги, записи, поиск).

### Рассмотренные варианты

1. **Redux + Redux Toolkit**
   - ✅ Предсказуемое состояние
   - ✅ DevTools
   - ✅ Стандарт индустрии
   - ❌ Много boilerplate даже с RTK
   - ❌ Overkill для простого UI

2. **MobX**
   - ✅ Меньше boilerplate
   - ✅ Реактивность
   - ❌ "Магия" может путать
   - ❌ Отход от функционального стиля

3. **Zustand**
   - ✅ Простой API
   - ✅ TypeScript friendly
   - ✅ Маленький размер
   - ❌ Менее популярен
   - ❌ Меньше экосистема

4. **React Hooks (useState, useReducer, Context)**
   - ✅ Нет дополнительных зависимостей
   - ✅ Встроено в React
   - ✅ Достаточно для нашего UI
   - ❌ Может стать сложным при росте
   - ❌ Нет DevTools

### Решение

**React Hooks** с custom hooks для бизнес-логики:

- `useState` для локального состояния
- `useReducer` для сложной логики
- `Context` для глобального состояния (если нужно)
- Custom hooks обращаются к Use Cases

### Обоснование

1. **Clean Architecture**: Состояние UI отделено от доменной логики
2. **Простота**: Минималистичный UI не требует сложного state management
3. **Use Cases**: Вся логика в application слое, React только отображает
4. **YAGNI**: Начинаем с простого, усложним если понадобится

### Последствия

**Положительные**:

- Нет дополнительных зависимостей
- Простота для новых разработчиков
- Меньше абстракций
- Custom hooks легко тестировать

**Отрицательные**:

- Возможны проблемы с производительностью при росте
- Нет time-travel debugging
- Сложнее отследить поток данных
- Возможная миграция на Redux в будущем

**Стратегия миграции**:
Если понадобится Redux, custom hooks легко переписать на использование Redux store, не меняя компоненты.

---

## Шаблон для новых ADR

```markdown
## ADR-XXX: [Название решения]

**Дата**: YYYY-MM-DD  
**Статус**: Предложено | Принято | Отклонено | Заменено  
**Автор**: [Имя]  
**Заменяет**: [ADR-XXX если применимо]  
**Заменено**: [ADR-XXX если применимо]  

### Контекст
[Опишите проблему и контекст, требующий решения]

### Рассмотренные варианты
1. **Вариант 1**
   - ✅ Плюсы
   - ❌ Минусы

2. **Вариант 2**
   - ✅ Плюсы
   - ❌ Минусы

### Решение
[Какой вариант выбран]

### Обоснование
[Почему именно это решение]

### Последствия
**Положительные**:
- [Что улучшится]

**Отрицательные**:
- [Какие появятся сложности]

**Риски**:
- [Что может пойти не так]
```
