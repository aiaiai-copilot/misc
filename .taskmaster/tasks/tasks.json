{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup Backend Package Structure",
        "description": "Create packages/backend with Express.js server foundation and basic project structure",
        "details": "Create packages/backend directory with package.json, TypeScript config, and basic Express server setup. Configure CORS for localhost:3000, add basic middleware (JSON parsing, error handling), and setup development scripts. Use Node.js 22.x, TypeScript 5.x, and Express framework as specified in PRD.",
        "testStrategy": "Verify server starts successfully on port 3001, CORS headers are present for localhost:3000, and basic health check endpoint responds correctly",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Setup PostgreSQL with Docker Compose",
        "description": "Create Docker Compose configuration for PostgreSQL 15+ database with initialization",
        "details": "Create docker-compose.yml in project root with PostgreSQL 15+ service configuration. Include environment variables for database credentials, volume mounting for data persistence, and port mapping (5432:5432). Create init.sql script with the exact schema from PRD: records table with UUID primary key, text content, text[] tags arrays, GIN index on normalized_tags, and timestamp fields.",
        "testStrategy": "Verify docker-compose up -d starts PostgreSQL successfully, database accepts connections, tables are created with correct schema, and indexes are properly configured",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create docker-compose.yml configuration file",
            "description": "Create docker-compose.yml in project root with PostgreSQL 15+ service configuration including environment variables for credentials, volume mounting for data persistence, and port mapping (5432:5432)",
            "dependencies": [],
            "details": "Create docker-compose.yml file with PostgreSQL 15-alpine service configuration. Include environment variables for POSTGRES_USER, POSTGRES_PASSWORD, POSTGRES_DB with default values (misc/misc_password/misc). Configure volume mounting for postgres_data:/var/lib/postgresql/data for data persistence. Map port 5432:5432 for external access. Add healthcheck using pg_isready command.",
            "status": "done",
            "testStrategy": "Verify docker-compose.yml syntax is valid using docker-compose config command and that all required PostgreSQL environment variables are properly configured"
          },
          {
            "id": 2,
            "title": "Create init.sql database initialization script",
            "description": "Create init.sql script with the exact database schema from PRD including records table with UUID primary key, text content, text[] tags arrays, GIN index on normalized_tags, and timestamp fields",
            "dependencies": [],
            "details": "Create docker/postgres/init.sql script with CREATE TABLE records statement matching PRD specification: id UUID PRIMARY KEY DEFAULT gen_random_uuid(), content TEXT NOT NULL, tags TEXT[] NOT NULL, normalized_tags TEXT[] NOT NULL, created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(), updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(), UNIQUE constraint on normalized_tags. Include CREATE INDEX statements for GIN index on normalized_tags and B-tree index on created_at DESC.",
            "status": "done",
            "testStrategy": "Verify SQL syntax is valid and that the schema matches exactly what the existing RecordRepository interface expects for data persistence"
          },
          {
            "id": 3,
            "title": "Configure Docker volume mounting for init.sql",
            "description": "Configure docker-compose.yml to mount the init.sql script into the PostgreSQL container's docker-entrypoint-initdb.d directory",
            "dependencies": [
              "2.1",
              "2.2"
            ],
            "details": "Add volume mapping in docker-compose.yml to mount ./docker/postgres/init.sql:/docker-entrypoint-initdb.d/init.sql:ro in the postgres service. This ensures the initialization script runs automatically when the PostgreSQL container starts for the first time. The :ro flag makes it read-only for security.",
            "status": "done",
            "testStrategy": "Verify that the init.sql script is properly mounted and executed by checking container logs during first startup and confirming tables are created"
          },
          {
            "id": 4,
            "title": "Test Docker Compose PostgreSQL startup",
            "description": "Test that docker-compose up -d successfully starts PostgreSQL service and accepts connections",
            "dependencies": [
              "2.1",
              "2.2",
              "2.3"
            ],
            "details": "Run docker-compose up -d and verify PostgreSQL container starts successfully without errors. Test database connectivity using psql or pg_isready commands. Verify that the database initialization script executed successfully by connecting to the database and checking that the records table exists with correct schema. Test that the GIN and B-tree indexes were created properly.",
            "status": "done",
            "testStrategy": "Use docker-compose logs postgres to check for startup errors, run pg_isready to test connectivity, and connect with psql to verify table and index creation with \\d records and \\di commands"
          },
          {
            "id": 5,
            "title": "Verify database schema and indexes",
            "description": "Verify that the database tables are created with correct schema including proper data types, constraints, and indexes as specified in PRD",
            "dependencies": [
              "2.4"
            ],
            "details": "Connect to the PostgreSQL database and verify the records table schema matches PRD exactly: UUID id field with proper default, TEXT content field, TEXT[] arrays for tags and normalized_tags, TIMESTAMP WITH TIME ZONE fields for created_at and updated_at with proper defaults. Verify UNIQUE constraint on normalized_tags field. Confirm GIN index exists on normalized_tags for efficient array searching and B-tree index on created_at for sorting performance.",
            "status": "done",
            "testStrategy": "Use psql commands \\d records to inspect table structure, \\di to list indexes, and run sample INSERT and SELECT operations to verify data types and constraints work correctly"
          }
        ]
      },
      {
        "id": 3,
        "title": "Create PostgreSQL Infrastructure Package",
        "description": "Implement packages/infrastructure/postgresql with PostgresRecordRepository",
        "details": "Create packages/infrastructure/postgresql package with PostgresRecordRepository class implementing the existing RecordRepository interface from packages/application/src/ports/record-repository.ts. Use pg library for PostgreSQL connections, implement connection pooling, and map between domain Records and database rows. Handle the existing Result<T, DomainError> pattern and convert tag arrays properly.",
        "testStrategy": "Write integration tests using Testcontainers or test database to verify all CRUD operations work correctly, proper error handling, and data consistency",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create PostgreSQL package structure and configuration",
            "description": "Set up packages/infrastructure/postgresql directory with package.json, TypeScript configuration, and pg library dependency",
            "dependencies": [],
            "details": "Create the basic package structure following the existing infrastructure package patterns. Include package.json with proper dependencies (pg, @types/pg), TypeScript configuration, and Jest setup. Configure the package to export the PostgresRecordRepository as the main implementation.",
            "status": "done",
            "testStrategy": "Verify package builds without errors and exports are properly defined"
          },
          {
            "id": 2,
            "title": "Implement PostgreSQL connection management",
            "description": "Create connection pool configuration and database connection utilities",
            "dependencies": [
              "3.1"
            ],
            "details": "Implement connection pooling using pg.Pool with proper configuration for the PostgreSQL database. Handle connection string configuration, connection timeout, and proper cleanup. Use the database credentials from docker-compose.yml (user: misc, password: misc_password, database: misc, host: localhost, port: 5432).",
            "status": "done",
            "testStrategy": "Test connection pool creation, connection acquisition/release, and proper error handling for connection failures"
          },
          {
            "id": 3,
            "title": "Implement record-to-database mapping utilities",
            "description": "Create mapping functions between domain Record objects and database rows",
            "dependencies": [
              "3.2"
            ],
            "details": "Implement bidirectional mapping between the domain Record class (with RecordId, RecordContent, Set<TagId>, createdAt, updatedAt) and database rows (id UUID, content TEXT, tags TEXT[], normalized_tags TEXT[], created_at TIMESTAMP, updated_at TIMESTAMP). Handle proper conversion of TagId objects to strings and back, convert Set<TagId> to TEXT[] arrays, and manage timestamp conversion.",
            "status": "done",
            "testStrategy": "Test mapping functions with various Record objects, verify tag array conversion, timestamp handling, and UUID conversion"
          },
          {
            "id": 4,
            "title": "Implement PostgresRecordRepository CRUD operations",
            "description": "Implement all RecordRepository interface methods with PostgreSQL queries",
            "dependencies": [
              "3.3"
            ],
            "details": "Implement all methods from RecordRepository interface: findById, findAll, search, findByTagIds, findByTagSet, save, update, delete, saveBatch, deleteAll, count, exists. Use proper SQL queries with parameterized statements, handle the Result<T, DomainError> pattern for all operations, and implement proper error handling for database errors (connection issues, constraint violations, etc.).",
            "status": "done",
            "testStrategy": "Unit tests for each repository method using mocked database connections, verify proper SQL query generation and parameter binding"
          },
          {
            "id": 5,
            "title": "Implement integration tests with Testcontainers",
            "description": "Create comprehensive integration tests using real PostgreSQL database",
            "dependencies": [
              "3.4"
            ],
            "details": "Set up integration tests using Testcontainers to spin up a real PostgreSQL instance. Test all CRUD operations against the actual database schema from init.sql. Verify tag search functionality using GIN indexes, test bulk operations, concurrent access scenarios, and proper error handling. Ensure tests clean up properly and run in isolation.",
            "status": "done",
            "testStrategy": "Integration tests covering all repository methods, tag search with complex queries, bulk operations, error scenarios (duplicate normalized_tags), and performance with large datasets"
          }
        ]
      },
      {
        "id": 4,
        "title": "Implement REST API Endpoints",
        "description": "Create Express routes for the 5 CRUD endpoints specified in PRD",
        "details": "Implement GET /api/records (with query params q, limit, offset), POST /api/records, PUT /api/records/:id, DELETE /api/records/:id, and GET /api/tags endpoints. Use Express Router, add request validation middleware, implement proper error handling (400, 404, 500), and ensure responses match PRD format. Map between RecordRepository interface and HTTP responses.",
        "testStrategy": "Write API integration tests covering all endpoints, status codes, request/response formats, error scenarios, and edge cases like invalid UUIDs and missing records",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Express router for API endpoints",
            "description": "Set up Express Router instance with base path /api and organize route handlers for records and tags endpoints",
            "dependencies": [],
            "details": "Create src/routes/api.ts with Express Router. Set up router structure with /records and /tags route groups. Configure router to be mounted at /api path in main Express app. Add proper TypeScript types for request/response objects.",
            "status": "done",
            "testStrategy": "Unit tests for router configuration and route mounting"
          },
          {
            "id": 2,
            "title": "Implement records CRUD endpoints",
            "description": "Create GET /api/records, POST /api/records, PUT /api/records/:id, and DELETE /api/records/:id endpoints with proper request/response handling",
            "dependencies": [
              "4.1"
            ],
            "details": "Implement 4 CRUD endpoints: GET /api/records with query params (q, limit, offset), POST /api/records with content body, PUT /api/records/:id with content body, DELETE /api/records/:id. Use PostgresRecordRepository to interact with database. Handle UUID validation for :id parameter.",
            "status": "done",
            "testStrategy": "Integration tests for each endpoint covering success cases, parameter validation, and database interactions"
          },
          {
            "id": 3,
            "title": "Implement tags endpoint for statistics",
            "description": "Create GET /api/tags endpoint that returns tag usage statistics for tag cloud visualization",
            "dependencies": [
              "4.1"
            ],
            "details": "Implement GET /api/tags endpoint that queries database for tag usage statistics. Return array of {tag: string, count: number} objects. Use PostgreSQL queries to aggregate tag counts from normalized_tags array field.",
            "status": "done",
            "testStrategy": "Integration tests for tag statistics endpoint covering various tag usage scenarios"
          },
          {
            "id": 4,
            "title": "Add request validation middleware",
            "description": "Create validation middleware for request body validation, query parameter validation, and UUID parameter validation",
            "dependencies": [
              "4.2",
              "4.3"
            ],
            "details": "Create middleware functions for: 1) UUID validation for :id parameters, 2) Request body validation for POST/PUT endpoints (content field required), 3) Query parameter validation for GET /api/records (q, limit, offset types). Use express middleware pattern with proper error handling.",
            "status": "done",
            "testStrategy": "Unit tests for each validation middleware covering valid inputs, invalid inputs, and edge cases"
          },
          {
            "id": 5,
            "title": "Implement comprehensive error handling",
            "description": "Add error handling middleware for proper HTTP status codes (400, 404, 500) and consistent error response format",
            "dependencies": [
              "4.2",
              "4.3",
              "4.4"
            ],
            "details": "Create error handling middleware that maps domain errors to HTTP status codes: DomainError types to 400/404, database errors to 500, validation errors to 400. Ensure consistent JSON error response format: {error: string, message?: string}. Handle Result<T, DomainError> pattern from repository calls.",
            "status": "done",
            "testStrategy": "Integration tests for error scenarios including invalid UUIDs, missing records, database errors, and validation failures"
          }
        ]
      },
      {
        "id": 5,
        "title": "Add Backend Workspace to Monorepo",
        "description": "Integrate backend package into existing yarn workspaces configuration",
        "details": "Update root package.json workspaces array to include packages/backend and packages/infrastructure/postgresql. Add backend build, test, and lint scripts to root package.json. Ensure TypeScript references are configured correctly and all packages can import from each other as needed.",
        "testStrategy": "Verify yarn install works, yarn build compiles all packages including backend, and dependency resolution works correctly across workspaces",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Create API Client for Frontend",
        "description": "Implement API client in packages/presentation/web to replace localStorage calls",
        "details": "Create an API client class that implements the same interface as the current localStorage-based data access. Use fetch API with proper error handling, timeout configuration, and response parsing. Map API responses to the existing DTO types used by the frontend. Ensure the client handles network errors gracefully.",
        "testStrategy": "Write unit tests for API client covering success cases, error handling, network failures, and proper request/response mapping",
        "priority": "high",
        "dependencies": [
          4
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Replace Frontend Data Layer",
        "description": "Replace localStorage usage with API calls in frontend components",
        "details": "Update packages/presentation/web to use the new API client instead of localStorage. Add loading states (isLoading flags) to components, implement error notifications for API failures, and ensure all existing functionality (search, create, update, delete, tag cloud) works with the backend. Preserve existing UI components and user experience.",
        "testStrategy": "Verify all frontend functionality works with API backend through manual testing and ensure existing E2E tests pass with minimal modifications",
        "priority": "high",
        "dependencies": [
          6
        ],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Create infrastructure-api package with HTTP repositories",
            "description": "Create new package @misc-poc/infrastructure-api with ApiRecordRepository and ApiTagRepository that use RecordApiClient. Implement IRecordRepository and ITagRepository interfaces from domain layer. These repositories will translate between API DTOs and domain entities.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 7
          },
          {
            "id": 2,
            "title": "Update ApplicationContext to use API-based repositories",
            "description": "Replace LocalStorage repositories with new API repositories in ApplicationContext. Update dependency injection container. Add API_BASE_URL configuration (default to http://localhost:3000). Keep same use case structure.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 7
          },
          {
            "id": 3,
            "title": "Add loading and error states to components",
            "description": "Update components to handle async API operations: add isLoading state during API calls, show loading spinners/overlays, implement error notifications using Sonner toast, handle network failures gracefully. Update MiscInputIntegrated and search components.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 7
          },
          {
            "id": 4,
            "title": "Update tests for API integration",
            "description": "Update existing tests to work with API repositories instead of localStorage. Add integration tests for API client error handling. Mock API responses in component tests. Ensure all existing functionality tests still pass.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 7
          },
          {
            "id": 5,
            "title": "Remove localStorage dependencies and verify functionality",
            "description": "Remove @misc-poc/infrastructure-localstorage dependency from presentation-web. Update package.json. Run full test suite. Verify all features work: search, create, update, delete, tag cloud. Test with backend running.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 7
          }
        ]
      },
      {
        "id": 8,
        "title": "Update Application Container Configuration",
        "description": "Modify application container to use PostgreSQL repository instead of localStorage",
        "details": "Update packages/application/src/application-container.ts to instantiate PostgresRecordRepository instead of localStorage repository. Configure database connection settings, environment variable handling, and dependency injection. Ensure all use cases continue to work with the new repository implementation.",
        "testStrategy": "Verify application starts successfully with PostgreSQL repository, all use cases function correctly, and no regression in business logic",
        "priority": "medium",
        "dependencies": [
          3,
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Update E2E Tests for API Backend",
        "description": "Modify existing E2E tests to work with PostgreSQL backend instead of localStorage",
        "details": "Update e2e test suite to start both backend server and frontend before running tests. Modify test setup to use PostgreSQL test database, ensure data cleanup between tests, and verify all existing E2E test scenarios still pass. Update any assertions that might be affected by API timing or data persistence.",
        "testStrategy": "Run full E2E test suite with PostgreSQL backend and verify 100% pass rate, with proper test isolation and cleanup",
        "priority": "medium",
        "dependencies": [
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Create Production Startup Scripts",
        "description": "Implement npm start command and documentation for complete system startup",
        "details": "Create unified startup scripts that launch both PostgreSQL (via docker-compose) and the full application stack. Update root package.json with 'start' script that handles the complete startup sequence. Create clear documentation for the two-step process: docker-compose up -d, then npm start. Add error checking and clear error messages if PostgreSQL is not running.",
        "testStrategy": "Verify complete system startup from clean state, ensure all components are accessible (frontend on 3000, API on 3001), and validate user can perform all core operations end-to-end",
        "priority": "low",
        "dependencies": [
          9
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Fix ES Module Resolution Errors in TypeScript Compilation",
        "description": "Resolve ES module resolution error preventing backend server startup caused by TypeScript emitting imports without .js extensions while Node.js ESM requires them.",
        "details": "The monorepo has mixed module configurations causing ES module resolution issues. The domain package uses 'type: module' (ESM) but TypeScript compiles imports without .js extensions, while Node.js ESM requires explicit extensions. The backend package uses CommonJS but imports from ESM packages. Fix by implementing one of two solutions: (1) Configure TypeScript with 'moduleResolution: bundler' and 'allowImportingTsExtensions: false' in all packages that need to emit .js extensions, and ensure consistent module type across packages, or (2) Remove 'type: module' from all package.json files and standardize on CommonJS. Update tsconfig.json files across packages/domain, packages/backend, packages/infrastructure/postgresql to use consistent module resolution. Ensure all cross-package imports work correctly after changes. Test with 'yarn build' and verify backend starts successfully with 'node packages/backend/dist/index.js'.",
        "testStrategy": "Run 'yarn build' to verify all packages compile without module resolution errors. Test backend startup with 'node packages/backend/dist/index.js' to confirm server starts successfully. Verify all package imports work correctly by running 'yarn typecheck' across all workspaces. Run integration tests to ensure cross-package dependencies function properly. Check that both CommonJS require() and ESM import statements work as expected throughout the codebase.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-10-02T17:53:14.910Z",
      "updated": "2025-10-04T03:58:58.950Z",
      "description": "Tasks for master context"
    }
  }
}