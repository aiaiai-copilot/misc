# MISC - PostgreSQL Migration MVP

## Project Goal
Migrate MISC from localStorage to PostgreSQL persistence while maintaining single-user local deployment and existing functionality.

## Context
- Current: Working localStorage-based prototype with Clean Architecture
- Target: PostgreSQL-backed system with REST API
- Constraint: Single-user, local deployment (no authentication)
- Philosophy: Radical simplicity - everything is tags

## Technology Stack
Backend:
- Node.js 22.x + TypeScript 5.x
- Express framework
- PostgreSQL 15+ in Docker
- Simple SQL init script (no TypeORM migrations)

Frontend:
- Existing React SPA (minimal changes)
- Replace localStorage with API calls
- Add loading states and error handling

Infrastructure:
- Docker Compose (PostgreSQL only)
- Local development setup

## Database Schema

```sql
CREATE TABLE records (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  content TEXT NOT NULL,
  tags TEXT[] NOT NULL,
  normalized_tags TEXT[] NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(normalized_tags)
);

CREATE INDEX idx_records_normalized_tags ON records USING GIN(normalized_tags);
CREATE INDEX idx_records_created_at ON records(created_at DESC);
```

## Fixed Settings (No user_settings table)
```typescript
const SETTINGS = {
  caseSensitive: false,
  removeAccents: true,
  maxTagLength: 100,
  maxTagsPerRecord: 50,
};
```

## API Endpoints

### GET /api/records
- Query params: q (search), limit (default 100), offset (default 0)
- Response: { records: Record[], total: number }
- Search by normalized tags

### POST /api/records
- Body: { content: string }
- Response: Record (201)
- Creates new record with tag extraction

### PUT /api/records/:id
- Params: id (UUID)
- Body: { content: string }
- Response: Record (200)
- Updates existing record

### DELETE /api/records/:id
- Params: id (UUID)
- Response: 204 No Content
- Deletes record

### GET /api/tags
- Response: [{ tag: string, count: number }]
- Tag statistics for cloud visualization

## Repository Interface (Unchanged)
```typescript
interface IRecordRepository {
  save(record: Record): Promise<Record>;
  findByTags(tags: Tag[]): Promise<Record[]>;
  findById(id: RecordId): Promise<Record | null>;
  delete(id: RecordId): Promise<void>;
  getTagStatistics(): Promise<Array<{ tag: string; count: number }>>;
}
```

## Implementation Phases

### Phase 1: Backend Foundation
1. Create packages/backend with Express
2. Setup CORS for localhost:3000
3. Basic error handling middleware
4. Docker Compose for PostgreSQL

### Phase 2: PostgreSQL Repository
1. Create packages/infrastructure/postgresql
2. Implement PostgresRecordRepository
3. Database initialization script (init.sql)
4. Connection pool configuration

### Phase 3: API Implementation
1. Implement 5 CRUD endpoints
2. Request/response validation
3. Error handling middleware
4. API integration tests

### Phase 4: Frontend Integration
1. Create API client in packages/presentation/web
2. Replace localStorage with API calls
3. Add loading states (isLoading flags)
4. Add error notifications
5. Keep UI components unchanged

### Phase 5: Testing & Polish
1. Update E2E tests for API backend
2. Integration tests for PostgresRecordRepository
3. End-to-end verification
4. Documentation updates

## Acceptance Criteria

### Data Persistence
- Records stored in PostgreSQL
- All CRUD operations work correctly
- Search returns accurate results based on normalized tags
- Tag normalization follows existing domain rules
- Data persists across application restarts

### API Functionality
- All endpoints return correct responses
- Proper error handling (400, 404, 500)
- CORS configured for localhost:3000
- JSON request/response format

### Frontend Behavior
- UI functionality unchanged from user perspective
- Loading states shown during API calls
- Error notifications displayed on failures
- All existing features work (search, create, update, delete)
- Tag cloud visualization works

### Architecture
- Clean Architecture maintained
- Domain logic unchanged
- Repository pattern correctly implemented
- Monorepo structure preserved

### Testing
- Existing domain tests pass (>95% coverage)
- Existing use case tests pass (>90% coverage)
- E2E tests updated and passing
- PostgreSQL repository integration tested

### Deployment
- docker-compose up -d starts PostgreSQL
- npm start launches full application
- Simple setup for local development
- Clear error messages if setup fails

## User Startup Flow
```bash
# 1. Start PostgreSQL
docker-compose up -d

# 2. Start application
npm start

# Application available at:
# - Frontend: http://localhost:3000
# - API: http://localhost:3001
```

## What We're NOT Doing
- Multi-user support
- Authentication (OAuth, JWT)
- Import/export functionality
- Production deployment (Nginx, SSL)
- Rate limiting and security hardening
- Performance optimization for concurrent users
- Complex migrations

## Key Constraints
- Preserve ALL existing business logic
- Maintain Clean Architecture principles
- Keep minimal UI philosophy
- Single-user deployment only
- Local development environment

## Success Metrics
1. All existing functionality works identically
2. Data persists in PostgreSQL correctly
3. E2E tests pass with backend API
4. Setup time < 5 minutes for new developer
5. No regressions in existing features
