# MISC (MindSection) - Consolidated Product Requirements Document for TaskMaster AI

## Executive Summary

MISC - минималистичная система управления информацией, основанная на единственном принципе: всё есть теги. Каждая запись представляет собой набор слов (тегов), разделённых пробелами. Система устраняет барьер между мыслью и записью, предлагая мгновенную фиксацию и поиск информации без традиционных структур организации данных.

В мире, перегруженном сложными системами организации информации, MISC предлагает радикальную альтернативу. Мы убираем формы, поля, папки, типы документов - оставляя только суть: слова и связи между ними.

---

# ЧАСТЬ 1: ВИДЕНИЕ И ФИЛОСОФИЯ ПРОДУКТА

## Философия

Каждая запись - это просто набор слов, разделенных пробелами. Каждое слово одновременно является и содержанием, и способом найти это содержание.

## Ключевая проблема

Существующие системы заметок заставляют пользователя думать о структуре вместо содержания:
- В какую папку сохранить?
- Какой тип документа выбрать?
- Какие поля заполнить?
- Как правильно назвать?

Это когнитивная нагрузка, которая мешает главному - быстрой фиксации информации.

## Решение

MISC устраняет барьер между мыслью и записью:

1. **Запись**: Просто введите слова через пробел
2. **Поиск**: Введите любые слова из записи - найдется всё, где они есть

Пример использования:
```
петр иванов телефон 89151234455 день-рождения март 15
github пароль qwerty123 igor@gmail.com
алла петрова день-рождения 8 апрель
google пароль qwerty567 alex@gmail.com
встреча завтра 15:00 офис проект_альфа
```

Набрав "петр телефон" - найдете контакт Петра.
Набрав "пароль" - увидите все сохраненные пароли.
Набрав "день-рождения" - увидите список нужных вам дней рождения.

## Целевая аудитория

### Первичная
- **Информационные работники**: Те, кто постоянно работает с разнородной информацией
- **Минималисты**: Ценители простых и элегантных решений
- **Продвинутые пользователи**: Те, кто устал от ограничений традиционных систем

### Вторичная
- **Обычные пользователи**: Ищущие простую альтернативу сложным приложениям
- **Разработчики**: Для быстрых технических заметок и сниппетов
- **Студенты и исследователи**: Для фиксации разрозненных фактов и идей

## Ключевые принципы продукта

1. **Радикальная простота**: Один механизм для всех типов информации
2. **Нулевой порог входа**: Не требует обучения
3. **Скорость в приоритете**: Мгновенная фиксация мысли
4. **Прозрачность**: Пользователь всегда понимает, как работает система
5. **Нет структуры - есть свобода**: 
   - Пользователь сам решает, как интерпретировать свои записи
   - Порядок слов сохраняется для естественной читаемости
6. **Скорость важнее формальности**: Мгновенная фиксация мысли без лишних действий
7. **Универсальность через простоту**: Один механизм для всех типов информации

## Манифест

MISC - это не просто приложение для заметок. Это философия управления информацией, где отсутствие строгости становится преимуществом. Где меньше действительно значит больше.

Мы верим, что лучший интерфейс - минималистичный, а лучшая система - та, которую не нужно изучать.

---

# ЧАСТЬ 2: АРХИТЕКТУРА И ТЕХНИЧЕСКИЕ ПРИНЦИПЫ

## Архитектурные принципы

- **Clean Architecture**: Независимость бизнес-логики от деталей реализации
- **Domain-First**: Доменная модель разрабатывается первой и не зависит от UI или БД
- **Test-Driven Development**: Разработка через тестирование с первого дня
- **Dependency Inversion**: Зависимости направлены к центру (к домену)
- **SOLID принципы**: Каждый компонент имеет единственную ответственность
- **YAGNI для прототипа**: Не реализуем то, что не нужно сейчас
- **Подготовка к эволюции**: Структура данных готова к будущим изменениям

## Слои архитектуры

| Слой | Ответственность | Зависит от | Тестирование |
|------|-----------------|------------|--------------|
| Domain | Бизнес-логика, правила | Ничего | >95% покрытие |
| Application | Orchestration, use cases | Domain | >90% покрытие |
| Infrastructure | Хранение, внешние сервисы | Domain (через интерфейсы) | Интеграционные тесты |
| Presentation | UI, обработка ввода | Application | Компонентные + E2E тесты |

## Технологический стек

- **Монорепозиторий**: yarn workspaces для управления пакетами
- **Язык**: TypeScript для всех слоёв
- **Node.js**: v22.18.0 (указано в .nvmrc)
- **Frontend фреймворк**: React (детали презентационного слоя)
- **CLI фреймворк**: Ink (React для терминала)
- **Сборщик**: Vite для web, esbuild для CLI
- **Тестирование**: Jest/Vitest для unit-тестов, Testing Library для компонентов

---

# ЧАСТЬ 3: ФУНКЦИОНАЛЬНЫЕ ТРЕБОВАНИЯ

## Core функциональность

### Управление записями

- **Создание записи**: Ввод набора тегов через пробел
- **Поиск записей**: Поиск по любой комбинации тегов (логика AND)
- **Редактирование записи**: Полная замена содержимого записи
- **Удаление записи**: Безвозвратное удаление
- **Уникальность записи**: Запись = уникальное множество тегов (порядок не важен для идентификации)
- **Сохранение порядка тегов**: При отображении записи теги показываются в том порядке, в котором их ввёл пользователь

### Работа с тегами

- **Определение тега**: Любая последовательность символов без пробелов
- **Ограничения тегов**: 
  - Запрещены служебные символы JSON: `{}[]:,"\`
  - Поддержка всех остальных Unicode символов
  - Автоматическое приведение к нижнему регистру (настраиваемо)
  - Опциональное удаление диакритических знаков (настраиваемо)
- **Нормализация тегов**:
  - Приведение к нижнему регистру для поиска
  - Удаление диакритики (é→e, ñ→n) для улучшения поиска (опционально)
  - Пример: "Café" и "cafe" найдутся по одному запросу
- **Автодополнение**: Подсказки на основе существующих тегов
- **Статистика использования**: Подсчёт частоты использования тегов
- **Порядок тегов в записи**: 
  - Порядок ввода тегов сохраняется для каждой записи
  - При редактировании пользователь может изменить порядок тегов
  - Порядок важен для читаемости, но не влияет на уникальность записи

### Интерфейс поиска

- **Инкрементальный поиск**: Результаты обновляются при вводе
- **Облако тегов**: Отображается когда результаты не помещаются на экран
  - Размер тега пропорционален частоте использования
  - Клик по тегу добавляет его к поисковому запросу
- **Список записей**: Отображается когда результаты помещаются на экран
  - Сортировка по дате создания (новые сверху)
  - Отображение полного содержимого записи (по возможности)

### Экспорт/Импорт

#### Функциональность
- **Экспорт всех данных**: В JSON формате с версионированием
- **Импорт данных**: Полная замена существующих данных (очистка + загрузка)
- **Версионирование формата**: Для обеспечения совместимости
- **Простота формата**: Только пользовательские данные, без внутренних идентификаторов

#### Формат данных
```json
{
  "version": "1.0",
  "records": [
    {
      "content": "ToDo встреча Петров 15:00",
      "createdAt": "2024-01-01T10:00:00Z",
      "updatedAt": "2024-01-01T10:00:00Z"
    }
  ],
  "metadata": {
    "exportedAt": "2024-01-15T12:00:00Z",
    "recordCount": 42,
    "normalizationRules": {
      "caseSensitive": false,
      "removeAccents": false
    }
  }
}
```

#### Безопасность импорта/экспорта

**Экспорт:**
- Не экспортируются: UUID записей и тегов
- Экспортируются: Content, даты создания/обновления
- Формат: Стандартный JSON с версионированием
- Размер: Предупреждение при экспорте > 1000 записей

**Импорт:**
- Полная замена: Все существующие данные удаляются
- Предупреждение: Обязательное подтверждение пользователя
- Резервная копия: Автоматическое создание перед импортом
- Валидация: Проверка структуры JSON перед импортом
- Новые UUID: Все записи и теги получают новые идентификаторы

---

# ЧАСТЬ 4: ПОЛЬЗОВАТЕЛЬСКИЙ ИНТЕРФЕЙС

## Основной интерфейс

- **Единое поле ввода**: Универсальное поле для поиска и создания записей
- **Адаптивное отображение**: 
  - Режим поиска по умолчанию
  - Предложение создать запись при отсутствии результатов
- **Минималистичный дизайн**: Фокус на содержимом, минимум визуальных элементов
- **Индикаторы состояния**:
  - Поиск: Визуальная индикация во время debounce задержки (например, троеточие или spinner)
  - Загрузка: Индикатор при выполнении операций

## Управление клавиатурой

- **Enter**: Сохранить новую запись / Открыть выбранную для редактирования
- **Escape**: Очистить поле ввода
- **Tab**: Автодополнение тега
- **↑/↓**: Навигация по результатам поиска
- **Delete**: Удалить выбранную запись

## Алгоритм работы основного интерфейса

### Поток ввода в единое поле
```
Пользователь вводит текст
    ↓
Debounce 300ms
    ↓
Поиск записей
    ↓
Найдено?
  ├─ Да → Помещается на экран?
  │       ├─ Да → Показать список
  │       └─ Нет → Показать облако тегов
  └─ Нет → Предложить создать запись
          └─ Enter → Создать
```

### Поток импорта/экспорта
```
Экспорт:
  Пользователь → Кнопка "Экспорт" → JSON файл (без UUID)

Импорт:
  Пользователь → Выбирает файл → Предупреждение о замене всех данных
    ↓
  Подтверждение → Полное удаление → Импорт записей → Создание новых UUID
```

## Состояния UI

```typescript
type UIMode = 
  | { type: 'empty' }
  | { type: 'searching'; query: string }
  | { type: 'list'; records: RecordDTO[] }
  | { type: 'cloud'; tags: TagCloudItemDTO[] }
  | { type: 'creating'; content: string }
  | { type: 'editing'; record: RecordDTO }
  | { type: 'no-results'; query: string }
  | { type: 'importing'; progress?: number }
  | { type: 'export-ready'; data: ExportDTO }
```

---

# ЧАСТЬ 5: НЕФУНКЦИОНАЛЬНЫЕ ТРЕБОВАНИЯ

## Производительность

- **Время отклика поиска**: < 100мс для 10,000 записей
- **Время сохранения**: < 50мс
- **Размер приложения**: < 500KB (gzipped)
- **Запуск приложения**: < 2 секунды
- **Автодополнение**: < 50мс для 10,000 тегов
- **Определение режима отображения**: < 10мс для 100 записей
- **Полный импорт**: < 2сек для 1,000 записей
- **Экспорт**: < 1сек для 10,000 записей

## Надёжность

- **Сохранение данных**: Автоматическое сохранение без потери данных
- **Валидация**: Проверка корректности на всех уровнях
- **Обработка ошибок**: Graceful degradation, информативные сообщения
- **Восстановление**: Возможность восстановления из экспортированных данных

## Юзабилити

- **Отзывчивый дизайн**: Адаптация под разные размеры экранов
- **Доступность**: Поддержка keyboard-only навигации
- **Обратная связь**: Визуальные индикаторы состояний
- **Время отклика UI**: < 16мс для плавности анимаций

## Тестируемость

- **Модульное тестирование**: Все компоненты должны быть тестируемы изолированно
- **Интеграционное тестирование**: Тесты взаимодействия между слоями
- **E2E тестирование**: Основные пользовательские сценарии
- **Тестовые данные**: Возможность генерации и загрузки тестовых данных

## Модульность и расширяемость

- **Независимость слоёв**: Изменения в одном слое не должны требовать изменений в других
- **Подключаемые хранилища**: Возможность смены localStorage на другие хранилища
- **Расширяемость функций**: Новые функции добавляются без изменения существующего кода
- **Конфигурируемость**: Настройки вынесены в конфигурацию

## Совместимость

- **Браузеры**: Последние 2 версии Chrome, Firefox, Safari, Edge
- **Минимальное разрешение**: 320px ширина
- **JavaScript**: ES2020+ с транспиляцией

---

# ЧАСТЬ 6: ДОМЕННАЯ МОДЕЛЬ

## Сущности (Entities)

### Record

**Описание**: Запись - основная сущность системы, представляет сохранённую пользователем информацию.

**Поля:**
- `id`: RecordId - уникальный идентификатор записи
- `content`: RecordContent - содержимое записи как ввёл пользователь (хранит порядок тегов)
- `tagIds`: Set<TagId> - множество идентификаторов тегов (для быстрого поиска)
- `createdAt`: Date - дата создания
- `updatedAt`: Date - дата последнего обновления

**Поведение:**
- `hasTag(tagId: TagId)`: boolean - проверка наличия тега
- `hasSameTagSet(other: Record)`: boolean - проверка на одинаковый набор тегов
- `equals(other: Record)`: boolean - сравнение по ID

**Инварианты:**
- ID неизменен после создания
- Content не может быть пустым
- Content должен содержать хотя бы один валидный тег
- tagIds содержит все теги из content (синхронизация)

### Tag

**Описание**: Тег как сущность - уникальный концепт в системе.

**Поля:**
- `id`: TagId - уникальный идентификатор тега
- `normalizedValue`: string - нормализованная форма для поиска и уникальности

**Поведение:**
- `equals(other: Tag)`: boolean - сравнение по ID

**Инварианты:**
- ID неизменен после создания
- normalizedValue уникален в системе

## Value Objects

- **RecordId**: Идентификатор записи (UUID)
- **TagId**: Идентификатор тега (UUID)
- **RecordContent**: Содержимое записи - строка тегов как ввёл пользователь
- **SearchQuery**: Поисковый запрос пользователя с нормализованными токенами

## Domain Services

### TagNormalizer
**Описание**: Сервис нормализации тегов.
**Правила:**
- Приведение к нижнему регистру
- Опционально: удаление диакритики (в конфигурации)

### TagParser
**Описание**: Сервис парсинга content в теги. Возвращает массив нормализованных значений тегов.

### TagValidator
**Описание**: Валидация токенов.
**Правила:**
- Длина от 1 до 100 символов (настраиваемо)
- Не содержит запрещённых символов: `{}[]:,"\`
- Не содержит пробелов

### RecordMatcher
**Описание**: Сервис проверки соответствия записи поисковому запросу.
**Логика:**
- Все токены из запроса должны присутствовать в записи (AND логика)
- Сравнение по нормализованным значениям

### RecordDuplicateChecker
**Описание**: Сервис проверки уникальности записи.
**Логика:**
- Записи дубликаты, если имеют одинаковый набор tagIds
- Порядок не важен

---

# ЧАСТЬ 7: APPLICATION LAYER - USE CASES

## CreateRecord

**Вход:** `{ content: string }`  
**Выход:** `RecordDTO`  
**Логика:**
1. Парсим content в токены
2. Валидируем каждый токен
3. Нормализуем токены
4. Находим или создаём теги для каждого уникального normalized значения
5. Проверяем на дубликат
6. Создаём Record с Set<TagId>
7. Сохраняем в репозитории
8. Возвращаем DTO

## SearchRecords

**Вход:** `{ query: string }`  
**Выход:** `SearchResultDTO`  
**Логика:**
1. Парсим и нормализуем запрос
2. Находим теги по normalized значениям
3. Находим записи, содержащие ВСЕ теги из запроса
4. Определяем режим отображения (список/облако)
5. Формируем результат

## UpdateRecord

**Вход:** `{ id: string, content: string }`  
**Выход:** `RecordDTO`  
**Логика:**
1. Находим запись
2. Парсим новый content
3. Находим/создаём теги
4. Проверяем на дубликат (исключая текущую запись)
5. Обновляем запись
6. Очищаем неиспользуемые теги
7. Возвращаем DTO

## DeleteRecord

**Вход:** `{ id: string }`  
**Выход:** `void`  
**Логика:**
1. Находим и удаляем запись
2. Проверяем и удаляем неиспользуемые теги

## GetTagSuggestions

**Вход:** `{ partial: string }`  
**Выход:** `string[]`  
**Логика:**
1. Нормализуем partial
2. Находим все теги, начинающиеся с partial
3. Возвращаем normalized значения для автодополнения

## ExportData

**Вход:** `{ format: 'json' }`  
**Выход:** `ExportDTO`  
**Логика:**
1. Получаем все записи
2. Формируем JSON с content и метаданными
3. НЕ экспортируем UUID записей и тегов (только content и даты)

## ImportData

**Вход:** `{ data: string, format: 'json' }`  
**Выход:** `ImportResultDTO`  
**Логика:**
1. **ПОЛНЫЙ ИМПОРТ**: Удаляем все существующие записи и теги
2. Парсим JSON данные
3. Для каждой записи из импорта:
   - Парсим content
   - Создаём новые теги (с новыми UUID)
   - Создаём новую запись (с новым UUID)
   - Сохраняем в репозитории
4. Возвращаем статистику импорта

**⚠️ Важно**: Импорт полностью заменяет все данные в системе!

---

# ЧАСТЬ 8: ИНФРАСТРУКТУРА И ХРАНЕНИЕ

## Схема хранения (localStorage)

```javascript
{
  "version": "2.1",
  
  // Теги - объект для O(1) доступа по ID
  "tags": {
    "uuid-tag-1": {
      "id": "uuid-tag-1",
      "normalizedValue": "todo"
    }
  },
  
  // Записи - объект для O(1) доступа по ID
  "records": {
    "uuid-record-1": {
      "id": "uuid-record-1",
      "content": "ToDo встреча Петров 15:00",
      "tagIds": ["uuid-tag-1", "uuid-tag-2", "uuid-tag-3", "uuid-tag-4"],
      "createdAt": "2024-01-01T10:00:00Z",
      "updatedAt": "2024-01-01T10:00:00Z"
    }
  },
  
  // Индексы для быстрого поиска
  "indexes": {
    // normalized значение → ID тега
    "normalizedToTagId": {
      "todo": "uuid-tag-1"
    },
    
    // ID тега → массив ID записей
    "tagToRecords": {
      "uuid-tag-1": ["uuid-record-1", "uuid-record-2"]
    }
  }
}
```

**Почему объекты, а не массивы:**
- O(1) доступ по ID вместо O(n) поиска
- Для 10,000 записей это критично
- Проще обновление и удаление

## Адаптеры

Реализация репозиториев через localStorage с поддержкой:
- Индексов для быстрого поиска
- Метода deleteAll() для полного импорта
- Транзакционности через UnitOfWork

## Порты (интерфейсы для Infrastructure)

**RecordRepository**: Управление записями
- CRUD операции
- Поиск по тегам с AND логикой
- Полная очистка для импорта

**TagRepository**: Управление тегами
- CRUD операции
- Поиск по нормализованному значению
- Автодополнение по префиксу
- Очистка неиспользуемых тегов

**UnitOfWork**: Паттерн для транзакционности операций

---

# ЧАСТЬ 9: НАСТРОЙКИ И КОНФИГУРАЦИЯ

## Настройки пользователя

### Базовые настройки
- **Регистрозависимость тегов**: Вкл/Выкл (по умолчанию: выкл)
- **Удаление диакритики**: Вкл/Выкл (по умолчанию: вкл)
- **Живой поиск**: Вкл/Выкл (по умолчанию: вкл)
- **Язык интерфейса**: Автоопределение с возможностью изменения

### Ограничения
- **Максимальная длина тега**: Настраиваемая (по умолчанию: 100 символов)
- **Максимальное количество тегов в записи**: Настраиваемое (по умолчанию: 50)
- **Максимальный размер хранилища**: Предупреждение при приближении к лимиту

## Конфигурация системы

**Теги:**
- maxLength: 100 символов
- maxPerRecord: 50 тегов

**Нормализация:**
- caseSensitive: false
- removeAccents: false

**Поиск:**
- debounceMs: 300
- liveSearch: true

**Отображение:**
- recordHeight: 60px
- Автоматическое переключение список/облако

**Хранилище:**
- maxSizeMB: 5
- backupBeforeImport: true

**Импорт/Экспорт:**
- warningThreshold: 1000 записей
- Версионирование формата

---

# ЧАСТЬ 10: ПОЛЬЗОВАТЕЛЬСКИЕ СЦЕНАРИИ

## Первое использование

1. Пользователь открывает приложение
2. Видит пустое поле ввода с плейсхолдером
3. Начинает вводить теги через пробел
4. Нажимает Enter - запись сохранена
5. Поле очищается, готово для новой записи

## Поиск информации

1. Пользователь вводит один или несколько тегов
2. Видит результаты в реальном времени
3. Если много результатов - видит облако тегов
4. Кликает по тегу в облаке для уточнения
5. Находит нужную запись

## Редактирование записи

1. Пользователь находит запись через поиск
2. Кликает по записи или выбирает стрелками + Enter
3. Запись загружается в поле ввода с сохранением исходного порядка тегов
4. Редактирует содержимое
5. Нажимает Enter - изменения сохранены

## Экспорт/Импорт данных

1. **Экспорт**: Пользователь нажимает "Экспорт" → получает JSON файл со всеми записями
2. **Импорт**: 
   - Пользователь выбирает JSON файл
   - Видит предупреждение о полной замене данных
   - Подтверждает → все старые данные удаляются
   - Новые данные загружаются из файла
   - Теги автоматически создаются на основе content

---

# ЧАСТЬ 11: ПЛАН РАЗРАБОТКИ

## Принципы разработки

1. **TDD First**: Сначала тесты, потом реализация
2. **Inside-Out**: От домена к внешним слоям
3. **Incremental**: Маленькие итерации с работающим кодом
4. **No Mocks in Domain**: Доменный слой тестируется без моков
5. **CI from Day One**: Непрерывная интеграция с первого коммита

## Фазы разработки

### Фаза 0: Инициализация проекта (1-2 дня)

#### Задачи:
- Создать репозиторий и базовую структуру
- Настроить yarn workspaces
- Настроить TypeScript конфигурацию
- Настроить Jest для всех пакетов
- Настроить ESLint и Prettier
- Настроить pre-commit hooks (Husky)
- Настроить GitHub Actions для CI
- Создать базовые package.json для всех пакетов

#### Критерии готовности:
- Можно запустить `yarn test` в любом пакете
- CI запускается при push и проверяет линтинг и тесты
- Структура папок соответствует project-structure.md

### Фаза 1: Domain Layer (3-5 дней)

#### Порядок реализации:

##### День 1: Value Objects
- RecordId с тестами (TDD)
- TagId с тестами (TDD)
- RecordContent с тестами (TDD)
- SearchQuery с тестами (TDD)
- Фабрики для Value Objects
- Интеграция и рефакторинг

##### День 2: Entities
- Tag entity с тестами (TDD)
- TagFactory с тестами
- Record entity с тестами (TDD)
- RecordFactory с тестами
- Проверка инвариантов

##### День 3: Domain Services
- TagNormalizer с тестами (TDD)
- TagValidator с тестами (TDD)
- TagParser с тестами (TDD)
- RecordMatcher с тестами (TDD)
- RecordDuplicateChecker с тестами (TDD)

##### День 4: Domain Errors и интеграция
- Все Domain Errors с тестами
- Result тип и утилиты
- Интеграционные тесты домена
- Рефакторинг и оптимизация
- Документация публичного API

#### Метрики успеха:
- Покрытие тестами > 95%
- Все тесты проходят < 1 сек
- Нет зависимостей кроме shared пакета

### Фаза 2: Application Layer (4-5 дней)

#### Порядок реализации:

##### День 1: Базовая инфраструктура
- Порты (Repository интерфейсы)
- Базовые DTO
- ApplicationError иерархия
- ApplicationConfig
- Моки репозиториев для тестов

##### День 2-3: Core Use Cases
- CreateRecord use case (TDD)
- SearchRecords use case (TDD)
- UpdateRecord use case (TDD)
- DeleteRecord use case (TDD)
- SearchModeDetector сервис

##### День 4: Import/Export
- ImportValidator с тестами
- ExportFormatter с тестами
- ImportData use case (TDD)
- ExportData use case (TDD)

##### День 5: Дополнительные сервисы
- GetTagSuggestions use case (TDD)
- TagCloudBuilder сервис
- ApplicationContainer
- Интеграционные тесты
- Документация

#### Метрики успеха:
- Покрытие тестами > 90%
- Use cases не зависят от деталей реализации
- Все операции возвращают Result тип

### Фаза 3: Infrastructure Layer - localStorage (3-4 дня)

#### Порядок реализации:

##### День 1: Storage Manager
- StorageSchema определение
- StorageManager с тестами (TDD)
- Сериализация/десериализация
- IndexManager с тестами (TDD)
- Оптимизация индексов

##### День 2: Repositories
- LocalStorageRecordRepository (TDD)
- CRUD операции с тестами
- LocalStorageTagRepository (TDD)
- Поиск и автодополнение

##### День 3: Unit of Work и миграции
- LocalStorageUnitOfWork
- Транзакционность операций
- MigrationManager
- Версионирование схемы

##### День 4: Интеграция и оптимизация
- Интеграционные тесты с реальным localStorage
- Тесты производительности
- Обработка edge cases (quota exceeded)
- Документация

#### Метрики успеха:
- Поиск 10,000 записей < 100ms
- Сохранение < 50ms
- Корректная обработка localStorage limits

### Фаза 4: Presentation Layer - Web (5-6 дней)

#### Порядок реализации:

##### День 1: Базовая инфраструктура React
- Настройка Vite
- Базовые компоненты и стили
- Контексты и провайдеры
- ApplicationContext setup
- Интеграция с Application layer

##### День 2: Основной UI
- SearchInput компонент (TDD)
- Debounce и keyboard handling
- RecordList компонент (TDD)
- RecordItem с действиями

##### День 3: Tag Cloud и автодополнение
- TagCloud компонент (TDD)
- Интерактивность и анимации
- AutoComplete компонент (TDD)
- Интеграция с SearchInput

##### День 4: Import/Export UI
- ImportExport компоненты
- Диалоги и прогресс
- Обработка ошибок
- Валидация на клиенте

##### День 5: Интеграция и полировка
- Keyboard shortcuts
- Адаптивный дизайн
- Темная тема (опционально)
- E2E тесты основных сценариев
- Оптимизация производительности

##### День 6: Финализация
- Accessibility (a11y) проверки
- Performance аудит
- Bundle size оптимизация
- Документация компонентов

#### Метрики успеха:
- Lighthouse score > 90
- Bundle size < 500KB (gzipped)
- FCP < 1.5s, TTI < 3s
- 100% keyboard navigable

### Фаза 5: CLI версия (3-4 дня) [Опционально]

#### Порядок реализации:

##### День 1: Базовая структура
- Настройка Ink
- Базовые компоненты CLI
- Интеграция с Application layer

##### День 2: Команды
- add команда
- search команда
- update/delete команды

##### День 3: Import/Export и финализация
- import/export команды
- Автодополнение для shell
- Man pages

#### Метрики успеха:
- Все основные операции доступны
- Время отклика < 100ms
- Работает в pipe chains

### Фаза 6: MVP с Backend

- Миграция на PostgreSQL
- REST API / GraphQL
- Авторизация и аутентификация
- Синхронизация данных
- Многопользовательность

---

# ЧАСТЬ 12: СТРУКТУРА ПРОЕКТА

## Общая структура монорепозитория

```
misc/
├── packages/                    # Пакеты монорепозитория
│   ├── domain/                  # Доменный слой (ядро)
│   ├── application/             # Прикладной слой (use cases)
│   ├── infrastructure/          # Инфраструктурный слой
│   │   └── localStorage/        # Реализация через localStorage
│   ├── presentation/            # Презентационный слой
│   │   ├── web/                # Web приложение (React)
│   │   └── cli/                # CLI приложение (Ink)
│   └── shared/                  # Общие утилиты и типы
├── docs/                        # Документация
├── scripts/                     # Скрипты сборки и деплоя
└── config/                      # Конфигурационные файлы
```

## Детальная структура пакета domain

```
domain/
├── src/
│   ├── entities/
│   │   ├── Record.ts
│   │   ├── Tag.ts
│   │   └── index.ts
│   ├── value-objects/
│   │   ├── RecordId.ts
│   │   ├── TagId.ts
│   │   ├── RecordContent.ts
│   │   ├── SearchQuery.ts
│   │   └── index.ts
│   ├── services/
│   │   ├── TagNormalizer.ts
│   │   ├── TagParser.ts
│   │   ├── TagValidator.ts
│   │   ├── RecordMatcher.ts
│   │   ├── RecordDuplicateChecker.ts
│   │   └── index.ts
│   ├── errors/
│   │   ├── DomainError.ts
│   │   ├── InvalidRecordContentError.ts
│   │   ├── InvalidTagError.ts
│   │   ├── DuplicateRecordError.ts
│   │   ├── TagLimitExceededError.ts
│   │   └── index.ts
│   ├── factories/
│   │   ├── RecordFactory.ts
│   │   ├── TagFactory.ts
│   │   └── index.ts
│   └── index.ts
├── tests/
│   ├── entities/
│   ├── value-objects/
│   ├── services/
│   └── test-utils/
├── package.json
├── tsconfig.json
└── README.md
```

## Детальная структура пакета application

```
application/
├── src/
│   ├── use-cases/
│   │   ├── CreateRecord/
│   │   ├── SearchRecords/
│   │   ├── UpdateRecord/
│   │   ├── DeleteRecord/
│   │   ├── GetTagSuggestions/
│   │   ├── ExportData/
│   │   ├── ImportData/
│   │   └── index.ts
│   ├── ports/
│   │   ├── RecordRepository.ts
│   │   ├── TagRepository.ts
│   │   ├── UnitOfWork.ts
│   │   └── index.ts
│   ├── dto/
│   │   ├── RecordDTO.ts
│   │   ├── SearchResultDTO.ts
│   │   ├── TagCloudItemDTO.ts
│   │   ├── ExportDTO.ts
│   │   ├── ImportResultDTO.ts
│   │   ├── ValidationResultDTO.ts
│   │   └── index.ts
│   ├── services/
│   │   ├── SearchModeDetector.ts
│   │   ├── TagCloudBuilder.ts
│   │   ├── ImportValidator.ts
│   │   ├── ExportFormatter.ts
│   │   └── index.ts
│   ├── errors/
│   │   └── ApplicationError.ts
│   ├── config/
│   │   ├── ApplicationConfig.ts
│   │   └── defaultConfig.ts
│   └── container/
│       ├── ApplicationContainer.ts
│       └── ApplicationContainerFactory.ts
├── tests/
├── package.json
├── tsconfig.json
└── README.md
```

## Зависимости между пакетами

```
shared → никого
   ↑
domain → shared
   ↑
application → domain, shared
   ↑
infrastructure → domain, application, shared
   ↑
presentation → application, shared
```

## Соглашения и правила

### Именование
- **Пакеты**: `@misc/package-name`
- **Файлы**: PascalCase для классов/интерфейсов, camelCase для функций
- **Тесты**: `*.test.ts` или `*.spec.ts`
- **Стили**: CSS Modules с `*.module.css`

### Правила импортов
- Абсолютные импорты внутри пакета: `@/entities/Record`
- Импорты между пакетами: `@misc/domain`
- Группировка импортов: внешние → пакеты misc → локальные

---

# ЧАСТЬ 13: МЕТРИКИ И КРИТЕРИИ УСПЕХА

## Целевые метрики

- Время до первой записи: < 10 секунд
- Время на обучение: < 1 минута
- Универсальность использования: 80% пользователей для 3+ типов информации
- Retention: 60% активных пользователей через месяц
- **Покрытие тестами**: 
  - Доменный слой: > 95%
  - Use Cases: > 90%
  - Общее покрытие: > 80%

## Технические метрики

- Покрытие тестами: > 80% общее, > 95% домен
- Время сборки: < 30 секунд
- Размер бандла: < 500KB gzipped
- Производительность: 60 FPS при всех интеракциях
- Нулевые критические баги в продакшене

## Продуктовые метрики

- Время до продуктивного использования: < 1 минуты
- NPS: > 50 после месяца использования
- Daily Active Users: > 100 для валидации
- Количество записей на пользователя: > 50 в первый месяц
- Разнообразие use cases: 3+ типа информации на пользователя

## Метрики качества кода

- Цикломатическая сложность: < 10 для всех функций
- Дублирование кода: < 3%
- Техдолг (по SonarQube): < 5 дней
- Время review PR: < 24 часов
- Среднее время исправления бага: < 48 часов

## Критерии приёмки

### Функциональные критерии
- Все основные use cases работают согласно спецификации
- Данные сохраняются и восстанавливаются корректно
- Поиск находит все релевантные записи
- Экспорт/импорт работает без потери данных
- Горячие клавиши работают как описано
- Нормализация с диакритикой работает корректно

### Архитектурные критерии
- Доменный слой не имеет зависимостей от других слоёв
- Use cases тестируются без UI и БД
- Репозитории легко заменяются (localStorage → PostgreSQL)
- Новые функции добавляются без изменения существующего кода
- Все слои имеют чёткие границы и интерфейсы

### Качественные критерии
- Покрытие тестами соответствует целевым метрикам
- Производительность соответствует требованиям
- Код соответствует принципам SOLID
- Документация покрывает все публичные API
- Отсутствуют критические и высокие баги

## Критерии готовности прототипа

**Domain Layer:**
- Record с content и Set<TagId>
- Tag с id и normalizedValue
- Сервисы парсинга и нормализации
- Валидация токенов

**Application Layer:**
- CreateRecord use case
- SearchRecords с автоопределением режима
- UpdateRecord с проверкой дубликатов
- DeleteRecord с очисткой тегов
- GetTagSuggestions для автодополнения
- ExportData без UUID
- ImportData с полной заменой

**Infrastructure Layer:**
- localStorage адаптеры
- Индексы для быстрого поиска
- deleteAll() методы для импорта
- Экспорт/импорт JSON

**Presentation Layer:**
- Единое поле ввода
- Автопереключение список/облако
- Клавиатурная навигация
- Индикаторы загрузки
- UI импорта/экспорта с предупреждениями

**Тестирование:**
- 95% покрытие Domain
- 90% покрытие Use Cases
- Интеграционные тесты Storage
- Тесты импорта/экспорта с проверкой полной замены

---

# ЧАСТЬ 14: РИСКИ И ОГРАНИЧЕНИЯ

## Технические риски

| Риск | Вероятность | Влияние | Митигация |
|------|-------------|---------|-----------|
| Сложность Clean Architecture для простого прототипа | Средняя | Среднее | Поэтапная реализация, начиная с домена |
| Производительность при большом количестве записей | Низкая | Высокое | Индексация, пагинация, виртуализация списков |
| localStorage лимиты | Средняя | Среднее | Мониторинг использования, предупреждения |
| Проблемы с нормализацией диакритики | Низкая | Низкое | Тестирование с разными языками, настройки |
| Большой bundle size | Средняя | Среднее | Code splitting, lazy loading, tree shaking |

## Продуктовые риски

| Риск | Вероятность | Влияние | Митигация |
|------|-------------|---------|-----------|
| "Слишком просто" для пользователей | Средняя | Высокое | Обучающие материалы, примеры использования |
| Путаница с концепцией "всё есть теги" | Средняя | Среднее | Интуитивный UI, onboarding |
| Дублирование записей из-за опечаток | Высокая | Низкое | Агрессивное автодополнение, fuzzy search в будущем |
| "Слишком просто" для корпоративных пользователей | Средняя | Среднее | Фокус на личном использовании, затем командные функции |
| Сложность монетизации open source | Средняя | Среднее | Облачная версия, премиум функции, поддержка |
| Конкуренция с giant tech | Низкая | Высокое | Ниша ультра-минимализма, преданное сообщество |

## Организационные риски

| Риск | Вероятность | Митигация |
|------|-------------|-----------|
| Переусложнение на старте | Высокая | Фокус на MVP функциональности |
| Долгий рефакторинг | Средняя | Маленькие итерации, постоянный рефакторинг |
| Потеря фокуса | Средняя | Чёткие критерии готовности для каждой фазы |

## Ограничения прототипа

- **Объём данных**: До 5-10MB (localStorage ограничения)
- **Многопользовательность**: Отсутствует
- **Синхронизация**: Отсутствует
- **Резервное копирование**: Только через ручной экспорт
- **Fuzzy поиск**: Отсутствует (точное совпадение тегов)
- **История изменений**: Отсутствует
- **Совместная работа**: Отсутствует

---

# ЧАСТЬ 15: ЭТАПЫ РАЗВИТИЯ ПРОДУКТА

## Прототип

- Web-приложение с локальным хранением
- Базовый функционал: создание, поиск, редактирование
- Автодополнение на основе существующих тегов
- Экспорт/импорт данных
- Валидация концепции

## MVP

- PostgreSQL backend
- Многопользовательность
- Авторизация и личные пространства
- Улучшенное автодополнение тегов

## Масштабирование

- Мобильные приложения (PWA → Native)
- CLI версия для разработчиков
- API для интеграций
- Синхронизация между устройствами
- Экспорт в различные форматы
- Браузерное расширение

## Экосистема

- Публичные и командные пространства
- API для сторонних разработчиков
- Плагины и расширения
- ML-подсказки (опционально, не нарушая простоту)
- Премиум функции для монетизации

## Подготовка к будущему (НЕ реализуем в прототипе)

### Что заложено в структуре
1. **Tags как entities** - позволит переименование
2. **UUID для всего** - позволит синхронизацию
3. **Нормализация в одном месте** - легко изменить правила
4. **Чистые слои** - легко заменить localStorage на API
5. **Версионирование экспорта** - позволит миграции формата

### Что НЕ делаем сейчас
1. ❌ События и EventBus
2. ❌ Переименование тегов
3. ❌ Слияние тегов
4. ❌ История изменений
5. ❌ Синхронизация
6. ❌ Инкрементальный импорт
7. ❌ Сложная валидация

---

# ЧАСТЬ 16: КОНКУРЕНТНЫЕ ПРЕИМУЩЕСТВА

1. **Радикальная простота**: Нет аналогов с таким уровнем минимализма
2. **Нулевой порог входа**: Не требует обучения
3. **Open Source**: Прозрачность и доверие сообщества
4. **Универсальность**: Заменяет множество специализированных инструментов

---

# ЧАСТЬ 17: ИНСТРУМЕНТЫ И ТЕХНОЛОГИИ РАЗРАБОТКИ

## Обязательные инструменты

- **IDE**: VS Code с расширениями для TypeScript
- **Node.js**: v22.18.0 (указано в .nvmrc)
- **Yarn**: v3+ (Berry)
- **Git**: Conventional Commits

## Рекомендуемые расширения VS Code

- ESLint
- Prettier
- Jest Runner
- GitLens
- Better Comments
- TODO Highlight

## Команды для разработки

```bash
# Инициализация проекта
yarn install
yarn build

# Разработка домена
cd packages/domain
yarn test:watch

# Разработка приложения
cd packages/application
yarn test:watch

# Запуск web версии
yarn dev:web

# Проверка покрытия
yarn test:coverage

# Полная проверка перед коммитом
yarn lint && yarn test && yarn build
```

## Definition of Done

### Для каждой задачи:
- Тесты написаны и проходят
- Код соответствует линтеру
- Документация написана
- PR создан и прошёл review
- CI проходит полностью

### Для каждой фазы:
- Все задачи выполнены
- Целевые метрики достигнуты
- Интеграционные тесты проходят
- Документация актуальна
- Нет критических багов

---

# ЧАСТЬ 18: ПЕРВЫЕ ШАГИ РАЗРАБОТКИ

## 1. Создать репозиторий
```bash
git init misc
cd misc
```

## 2. Инициализировать yarn workspaces
```bash
yarn init -y
yarn set version berry
yarn config set nodeLinker node-modules
```

## 3. Создать базовую структуру
```bash
mkdir -p packages/{domain,application,shared}
mkdir -p packages/infrastructure/localStorage
mkdir -p packages/presentation/{web,cli}
```

## 4. Настроить TypeScript и Jest
```bash
yarn add -D typescript jest @types/jest ts-jest
yarn add -D @typescript-eslint/parser @typescript-eslint/eslint-plugin
yarn add -D prettier eslint-config-prettier
```

## 5. Создать первый тест
```typescript
// packages/domain/tests/value-objects/RecordId.test.ts
describe('RecordId', () => {
  it('should generate unique UUID when created without value', () => {
    // Red phase - тест должен упасть
    expect(true).toBe(false);
  });
});
```

## 6. Запустить TDD цикл
```bash
cd packages/domain
yarn test:watch
```

И начать реализацию через Red-Green-Refactor!

## TDD цикл:
1. **Red**: Написать тест, который не проходит
2. **Green**: Написать минимальный код для прохождения теста
3. **Refactor**: Улучшить код, сохраняя зелёные тесты

## Clean Architecture checklist:
- Домен не знает о других слоях
- Application оркестрирует, но не содержит бизнес-логику
- Infrastructure реализует интерфейсы из Application
- Presentation использует только Application layer
- Зависимости направлены внутрь

## Приоритеты:
1. **Работающий код** > Идеальная архитектура
2. **Простота** > Гибкость на будущее
3. **Тесты** > Документация
4. **Рефакторинг** > Переписывание с нуля

---

# ЗАКЛЮЧЕНИЕ

MISC - это не просто система управления информацией, это философия радикальной простоты. Проект построен на принципах Clean Architecture с использованием TDD, что обеспечивает высокое качество кода и возможность эволюции системы.

Ключевые особенности проекта:
- Единственный принцип: всё есть теги
- Мгновенная фиксация информации
- Нулевой порог входа
- Чистая архитектура с независимыми слоями
- Разработка через тестирование
- Готовность к эволюции и масштабированию

Проект готов к поэтапной реализации, начиная с доменного слоя и заканчивая полноценным веб-приложением с возможностью дальнейшего развития в многопользовательскую систему с синхронизацией и API.

Удачной разработки! 🚀
